from datetime import datetime, UTC
from http.server import BaseHTTPRequestHandler, HTTPServer
import os
from typing import Final
{% if include_pydantic %}
from pydantic import BaseModel, field_validator
{% else %}
import json
from typing import TypedDict
{% endif %}

HOST: Final[str] = "0.0.0.0"
PORT: Final[int] = int(os.environ.get("PORT", "7123"))

{% if include_pydantic %}


class HelloResponse(BaseModel):
    """Resposta JSON para o endpoint raiz (/)."""

    message: str
    now: datetime

    @field_validator("now")
    @classmethod
    def _ensure_tz(cls, v: datetime) -> datetime:
        """Valida que 'now' é timezone-aware."""
        if v.tzinfo is None or v.tzinfo.utcoffset(v) is None:
            raise ValueError("datetime precisa ter timezone")
        return v

    def to_json_bytes(self) -> bytes:
        """Serializa o modelo para JSON em bytes (UTF-8)."""
        return self.model_dump_json().encode("utf-8")


class Handler(BaseHTTPRequestHandler):
    """Handler HTTP minimal que serve um JSON em '/'."""

    def do_GET(self) -> None:
        if self.path != "/":
            self.send_error(404, "Not Found")
            return

        now = datetime.now(UTC).astimezone()
        payload = HelloResponse(message="Hello, world!", now=now)
        body = payload.to_json_bytes()

        self.send_response(200)
        self.send_header("Content-Type", "application/json; charset=utf-8")
        self.send_header("Content-Length", str(len(body)))
        self.end_headers()
        self.wfile.write(body)

    def log_message(self, format: str, *args) -> None:
        """Silencia logging padrão para manter testes limpos."""
        return

{% else %}


class HelloResponseDict(TypedDict):
    """Resposta JSON para o endpoint raiz (/)."""

    message: str
    now: str  # ISO 8601 string


def make_hello_response() -> HelloResponseDict:
    """Cria o payload com datetime timezone-aware e retorna dict serializável."""
    now = datetime.now(UTC).astimezone().isoformat()
    return {"message": "Hello, world!", "now": now}


class Handler(BaseHTTPRequestHandler):
    """Handler HTTP minimal que serve um JSON em '/'."""

    def do_GET(self) -> None:
        if self.path != "/":
            self.send_error(404, "Not Found")
            return

        payload = make_hello_response()
        body = json.dumps(payload, ensure_ascii=False).encode("utf-8")

        self.send_response(200)
        self.send_header("Content-Type", "application/json; charset=utf-8")
        self.send_header("Content-Length", str(len(body)))
        self.end_headers()
        self.wfile.write(body)

    def log_message(self, format: str, *args) -> None:
        """Silencia logging padrão para manter testes limpos."""
        return

{% endif %}


if __name__ == "__main__":
    with HTTPServer((HOST, PORT), Handler) as httpd:
        print(f"servindo em http://{HOST}:{PORT} (CTRL+C para sair)")
        httpd.serve_forever()
